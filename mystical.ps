%!
(dmmlib/base.ps) run
(dmmlib/textbase.ps) run
(dmmlib/lines.ps) run
(dmmlib/polar.ps) run

/nib_angle -60 def

/nib_matrix matrix currentmatrix def
/set_nib_matrix {
    /nib_matrix matrix currentmatrix def
} def
/nstroke {
    gsave
        nib_matrix setmatrix
        24 recip setlinewidth
        nib_angle rotate
        0.5 1 scale
        0.5 callistroke
    grestore
    newpath
} def
% /nstroke {stroke} def

/ring_debug false def
% ring_spacing is distance from parent ring radius to child ring full_radius
% ring_spacing needs to be at least 1
/ring_spacing 2 def
/ring_width 1 def
/std_sigil_width 1.25 def
% sibling_spacing is distance between rings with same parent
/sibling_spacing 0.5 def
/sibling_hs sibling_spacing half def
/ring_halfwidth 0.5 def
/buffer 100 string def
/Times 0.5 selectfont
/draw_ring [/spell] {
    spell begin
        24 recip setlinewidth
        set_nib_matrix
        % borders based on rtype
        rtype /dict eq {
            components length circumference cvi maximum
            dup { radius ring_halfwidth add 0 goto } circrepeat
            closepath whitefill nstroke
            dup { radius ring_halfwidth 0.75 mul add 0 goto } circrepeat
            closepath nstroke
            { radius ring_halfwidth sub 0 goto } circrepeat
            closepath nstroke
        } {
            0 0 radius ring_halfwidth add circle whitefill nstroke
            0 0 radius ring_halfwidth sub circle nstroke
        } ifelse
        % draw each ring element
        components { /Token arg
            gsave
                Token /aflag get {
                    Token draw_link
                } if
                Token /aflag get not Token /defligature known or {
                    Token draw_sigil
                } if
            grestore
        } forall
        % star for xarray
        rtype /xarray eq {
            /comp_n components length def
            /star_radius radius ring_halfwidth sub def
            comp_n 2 le {
                5 { star_radius half 0 goto } 2 schlafrepeat closepath nstroke
            } {
                /full_step comp_n 3 idiv def
                /star_rings comp_n full_step gcd def
                /star_points comp_n star_rings idiv def
                /star_step full_step star_rings idiv def
                0 1 star_rings 1 sub {
                    gsave
                        % dup star_rings div 360 mul setkatebowcolor
                        360 comp_n div mul rotate
                        star_points {star_radius 0 goto} star_step schlafrepeat 
                        closepath nstroke
                    grestore
                } for
            } ifelse
        } if
        % debug ring positions
        ring_debug {
            gsave
                1 0 0 setrgbcolor
                0 0 radius circle stroke
                0 1 0 setrgbcolor
                0 0 full_radius circle stroke
            grestore
        } if
    end
} 0 false dict_safe_func

% sigil_bank is in the other file
(sigils.ps) run
/draw_sigil [/Token] {
    Token begin
    gsave
        angle rotate
        parent /radius get 0 translate
        set_nib_matrix
        otype /nametype eq {
            xflag not {
                gsave
                    3 {
                        -1 0 goto
                    } circrepeat closepath nstroke
                grestore
            } if
        } if
        otype /return ne {
            0.75 softscale
            90 rotate
        } if
        sigil_bank name known {
            gsave
                sigil_bank name get exec
                otype /return eq parent /root known and {
                    0.5 0 goto 1 0 goto nstroke
                } if
            grestore
        } {
            gsave
                /fakerad parent /radius get 0.75 div def
                0 fakerad translate
                name buffer cvs fakerad neg circle_center_show
            grestore
        } ifelse
        false {
            0 -0.75 translate
            2 recip softscale
            xflag {
                /Times-Bold 0.5 selectfont
            } if
            otype buffer cvs centershow
        } if
    grestore
    end
} 0 false dict_safe_func
/draw_link [/Token] {
    Token begin
    gsave
        /r0 parent /radius get def
        /r4 r0 Token /offset get add def 
        Token /defligature known {
            % special sigil handling
            /r0 ring_halfwidth adddef
        } if
        /r3 r4 ring /radius get sub ring_halfwidth sub def
        /rstep r3 r0 sub 3 div def
        /r1 r0 rstep add def
        /r2 r1 rstep add def
        angle rotate
        /local_angle ring_angle angle sub def
        set_nib_matrix
        r0 0 polar goto
        r1 0 polar
        r2 local_angle polar
        r3 local_angle polar curveto nstroke
        r0 0 polar
        ring /rtype get /xarray eq {
            0.125 spcircle whitefill nstroke
        } {
            dot
        } ifelse
        local_angle rotate
        r4 0 translate
        180 rotate
        ring draw_ring
    grestore
    % ring debug
    ring_debug {
        gsave
            1 0.5 0 setrgbcolor
            gsave
                ring_angle rotate
                0 0 goto
                0 0 r4 
                ring /full_radius get r4 div asin dup neg arcn
                closepath stroke
            grestore
        grestore
    } if
    end
} 0 false dict_safe_func

/kerning true def
/parsecode [/Ring /code /code_pos] {
    10 dict begin
        % Ring: Ring object to write into, type is set
        % code:  input code
        % code_pos: position in code being parsed

        /i 0 def
        /code_len code length def

        /find_offset { /inner_ring arg /source arg
            source /offset
            inner_ring /full_radius get ring_spacing add put
        } def

        Ring /cursor 0 put
        Ring /components code_len 1 add code_pos sub array put
        Ring /circumference 0.5 put  % leave room for return
        
        code_len 0 gt {
            {
                /Token << >> def
                /parent Ring def
                /components Ring /components get def
                /cursor Ring /cursor get def
                components cursor Token put
                % careful not to execute code piece before cvlit
                code code_pos get
                dup type cvlit /otype arg
                dup xcheck /xflag arg
                cvlit /literal arg
                /aflag otype /arraytype eq def
                /literal_s literal buffer cvs def

                % check for def-ligature
                /skip_token false def
                Ring /rtype get /xarray eq literal /def eq and {
                    cursor 2 ge {
                        % prev is true circle
                        /previous components cursor 1 sub get def
                        /prevprev components cursor 2 sub get def
                        previous /aflag get previous /otype get /nametype ne and {
                            prevprev /aflag get not prevprev /otype get /nametype eq and {
                                % set up ligature - add ring info to name
                                [/offset /ring /aflag] { /field arg
                                    prevprev field
                                    previous field get 
                                    put
                                } forall
                                Ring /circumference previous /width get neg addput
                                prevprev /defligature true put
                                /cursor -2 adddef
                                /skip_token true def
                                /code_pos 1 adddef
                            } if
                        } if
                    } if
                } if
                /cursor 1 adddef
                Ring /cursor cursor put
                skip_token not {
                    % [ for vi
                    % don't otherwise deal with these tokens
                    literal_s (]) eq { exit } if
                    literal_s (>>) eq { exit } if
                    literal_s ([) eq literal_s (<<) eq or {
                        % ] for vi
                        /array_ring << /rtype literal_s (<<) eq {/dict} {/array} ifelse >> def
                        Token /ring array_ring put
                        Token /signal true put
                        /code_pos 1 adddef
                        array_ring code code_pos parsecode /code_pos arg
                        Token array_ring find_offset
                        Token /name array_ring /rtype get put
                        /aflag true def
                    } {
                        % Handle recursion for executable arrays
                        otype /arraytype eq {
                            /inner_ring <<
                                /rtype xflag { /xarray } { /array } ifelse
                            >> def
                            Token /ring inner_ring put
                            inner_ring literal 0 parsecode pop
                            Token inner_ring find_offset
                            Token /name inner_ring /rtype get put
                        } {
                            Token /name literal put
                        } ifelse
                    } ifelse
                    kerning {
                        aflag {
                            0.75
                        } {
                            sigil_bank literal known {
                                std_sigil_width
                            } {
                                literal buffer cvs stringwidth pop ( ) stringwidth pop add
                            } ifelse
                        } ifelse
                        % even if text is short names must be sigil-width
                        otype /nametype eq {
                            std_sigil_width max
                        } if
                    } {
                        1
                    } ifelse
                    /width arg
                    /position Ring /circumference get width half add def
                    Ring /circumference width addput

                    [/otype /xflag /aflag /position /width /parent] {
                        Token exch dup cvx exec put
                    } forall

                    /code_pos 1 adddef
                    code_pos code length ge { exit } if
                } if
            } loop
            % temporary shenanigans - cursor might be two off the end
            components Ring /cursor get 1 sub get length 0 eq {
                Ring /cursor -1 addput
            } if
        } if
        /circumference Ring /circumference get def
        /cursor Ring /cursor get def
        /components Ring /components get def

        /end_token <<
            /otype /return
            /xflag false
            /aflag false
            /position circumference 0.5 add
            /name Ring /rtype get /xarray eq { /RETURN } { /COMPLETE } ifelse
            /parent Ring
        >> def
        components cursor end_token put
        /cursor 1 adddef

        % determine ring dimensions
        /components components 0 cursor getinterval def
        /circumference 0.5 adddef

        % set angles of all sigils before messing with circumference
        components { /component arg
            /angle component /position get circumference div 360 mul def
            component /angle angle put
            component /position undef
        } forall

        /circumference circumference 2 PI mul maximum def
        /radius circumference PI div half def

        % layout
        % find largest dependent ring
        /max_sub 0.5 def
        % ordered list of components and their span info
        /ring_components components length array def
        /rci 0 def
        components { /component arg
            component /ring known {
                /angle component /angle get def
                component /ring_angle angle put
                /c_ring component /ring get def
                /sub_offset
                    c_ring /full_radius get component /offset get add 
                    def
                sub_offset max_sub gt {
                    /max_sub sub_offset def
                } if
                % we need:
                % angle
                % center_offset (ring radius plus offset)
                % angle span (radius in either direction)
                /center_offset radius component /offset get add def
                /angle_span c_ring /full_radius get sibling_hs add center_offset div asin def
                /ring_span <<
                    /ring c_ring
                    /full_radius c_ring /full_radius get
                    /ring_angle angle
                    /center_offset center_offset
                    /angle_span angle_span
                >> def
                ring_components rci [component ring_span] put
                /rci 1 adddef
            } if
        } forall

        /ring_components ring_components 0 rci getinterval def
        ring_components length 1 gt {
            % check for everyone having room
            /total_spans 0 def
            ring_components { aload pop /ring_span arg /component arg
                ring_span /angle_span get 2 mul total_spans add
                /total_spans arg
            } forall
            Ring /total_spans total_spans put
            total_spans 360 gt {
                % not enough room, push everyone out and space evenly
                /adjustment 360 total_spans div def
                /angle_tracker 0 def
                ring_components { aload pop /ring_span arg /component arg
                    /full_radius ring_span /full_radius get def
                    /new_span ring_span /angle_span get adjustment mul def
                    /increase
                        full_radius sibling_hs add
                        new_span sin div
                        ring_span /center_offset get sub
                    def
                    /c_ring component /ring get def
                    /new_offset component /offset get increase add def
                    component /offset new_offset put
                    /angle_span full_radius sibling_hs add new_offset radius add div asin def
                    component /ring_angle angle_tracker angle_span add put
                    /angle_tracker angle_span 2 mul adddef

                    /sub_offset
                        c_ring /full_radius get component /offset get add 
                        def
                    sub_offset max_sub gt {
                        /max_sub sub_offset def
                    } if
                } forall
            } {
                % check for jostling
                % create differential list
                /diff_list ring_components length 1 add array def
                /last_component ring_components length 1 sub def
                /last_diff ring_components length def
                diff_list 0 ring_components 0 get 1 get
                    dup /ring_angle get exch /angle_span get sub
                put
                1 1 last_component { /i arg
                    diff_list i
                    /span_a ring_components i 1 sub get 1 get def
                    /span_b ring_components i get 1 get def
                    span_b dup /ring_angle get exch /angle_span get sub
                    span_a dup /ring_angle get exch /angle_span get add sub 
                    put
                } for
                diff_list last_diff ring_components last_component get 1 get
                    dup /ring_angle get exch /angle_span get add
                    360 exch sub
                put

                % calculate optimal diff_list
                % move negative edges to first positive neighbor
                0 1 last_diff { /i arg
                    {
                        diff_list i get 0 ge { exit } if
                        /left i 1 sub def
                        {
                            left 0 lt {exit} if
                            diff_list left get 0 gt { exit } if
                            /left -1 adddef
                        } loop
                        /right i 1 add def
                        {
                            right last_diff gt {exit} if
                            diff_list right get 0 gt { exit } if
                            /right 1 adddef
                        } loop
                        left 0 ge {
                            right last_diff le {
                                % both sides available
                                /remove_amount 
                                    diff_list left get
                                    diff_list right get minimum
                                    diff_list i get half minimum
                                def
                                diff_list left remove_amount addput
                                diff_list right remove_amount addput
                                diff_list i remove_amount -2 mul addput
                            } {
                                % only left is available
                                /remove_amount diff_list left get diff_list i get minimum def
                                diff_list left remove_amount addput
                                diff_list i remove_amount neg addput
                            } ifelse
                        } {
                            % left is off side
                            right last_diff le {
                                % only right is available
                                /remove_amount diff_list right get diff_list i get minimum def
                                diff_list right remove_amount addput
                                diff_list i remove_amount neg addput
                            } {
                                [(both sides off)] == die
                            } ifelse
                        } ifelse
                        exit
                    } loop
                } for
                % spread negative centers to positive neighbors
                % update ring_angles to match diff_list
                /ring_cursor 0 def
                0 1 last_component { /i arg
                    /current_component ring_components i get def
                    /ring_cursor diff_list i get adddef
                    /ring_cursor current_component 1 get /angle_span get adddef
                    current_component 0 get /ring_angle ring_cursor put
                    /ring_cursor current_component 1 get /angle_span get adddef
                } for

            } ifelse
        } if

        /full_radius radius max_sub add def

        Ring /components components put
        Ring /circumference circumference put
        Ring /radius radius put
        Ring /full_radius full_radius put
        code_pos
    end
} 1 false dict_safe_func

/mystical_get_spell {
    10 dict begin
        /input_code arg
        % determine type
        /xflag false def
        currentdict /input_code get xcheck {
            /xflag true def
            currentdict /input_code get cvlit /input_code arg
        } if
        /rtype xflag { /xarray} {input_code type cvlit } ifelse def
        % parse into Ring object
        /spell << /rtype rtype /root true >> def
        spell input_code 0 parsecode pop
        spell
    end
} def
/mystical_draw_spell { /spell arg
    gsave
        spell /full_radius get recip dup scale
        spell draw_ring
    grestore
} def
/mystical {
    10 dict begin
        mystical_get_spell /spell arg
        spell mystical_draw_spell
    end
} def

/mystical_evoke { /evocation arg
    evocation where { evocation get mystical } if
} def

/mystical_evoke_label { /evocation arg
    evocation where {
        evocation get mystical_get_spell /spell arg
        gsave
            spell /full_radius get recip dup scale
            % spell draw_ring
            % false token for label
            <<
                /name evocation /otype /nametype 
                /xflag false /aflag true
                /position 0 /angle -90 /parent <<
                    /radius spell /full_radius get neg
                >>
                /ring spell /ring_angle -90 /offset spell /full_radius get
                /defligature true
            >> dup draw_sigil draw_link
        grestore
    } if
} def

