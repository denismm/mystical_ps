%!
(dmmlib/base.ps) run
(dmmlib/textbase.ps) run
(dmmlib/lines.ps) run
(dmmlib/polar.ps) run


/nib_angle -30 def

/nstroke {
    gsave
        nib_angle rotate
        0.5 1 scale
        0.5 callistroke
    grestore
    newpath
} def
/nstroke {stroke} def

/ring_spacing 2 def     % this needs to be at least 1
/buffer 100 string def
/Times 0.5 selectfont
/draw_ring { /spell arg
    /rad spell /radius get def
    0 0 rad 0.5 add circle whitefill nstroke
    0 0 rad 0.5 sub circle nstroke
    spell /components get { /Token arg
        gsave
            Token draw_sigil
        grestore
    } forall
    false {
        gsave
            1 0 0 setrgbcolor
            0 0 rad circle stroke
            0 1 0 setrgbcolor
            spell /full_radius known {
                0 0 spell /full_radius get circle stroke
            } if
        grestore
    } if
} def

% sigil_bank is in the other file
(sigils.ps) run
/draw_sigil { /Token arg
    10 dict begin
    /skip_sigil false def
    /otype Token /otype get def
    /aflag Token /aflag get def
    /xflag Token /xflag get def
    /parent Token /parent get def
    /angle Token /angle get def
    aflag {
        /skip_sigil true def
        /ring_angle Token /ring_angle get def
        /inner_ring Token /ring get def
        gsave
            /r0 parent /radius get def
            /r4 r0 Token /offset get add def 
            /r3 r4 inner_ring /radius get sub def
            /rstep r3 r0 sub 3 div def
            /r1 r0 rstep add def
            /r2 r1 rstep add def
            r0 angle polar
            xflag {
                0.125 spcircle whitefill nstroke
            } {
                dot
            } ifelse
            r0 angle polar goto
            r1 angle polar
            r2 ring_angle polar
            r3 ring_angle polar curveto nstroke
            ring_angle rotate
            r4 0 translate
            180 rotate
            inner_ring draw_ring
        grestore
    } if
    angle rotate
    parent /radius get 0 translate
    otype /return ne {
        0.75 softscale
        90 rotate
    } if
    otype /nametype eq {
        xflag not {
            gsave
                3 {
                    0 1 goto
                } circrepeat closepath nstroke
            grestore
            0.75 softscale
        } if
    } if
    skip_sigil not {
        /literal Token /name get def
        sigil_bank literal known {
            gsave
                sigil_bank literal get exec
            grestore
        } {
            gsave
                /fakerad rad 0.75 div def
                0 fakerad translate
                literal buffer cvs fakerad neg circle_center_show
            grestore
        } ifelse
    } if
    false {
        0 -0.75 translate
        2 recip softscale
        xflag {
            /Times-Bold 0.5 selectfont
        } if
        otype buffer cvs centershow
    } if
    end
} def

/kerning true def
/parsecode {
    10 dict begin
        /code arg       % input code
        /input_ring arg       % Ring object to write into, type is set


        /ring_stack [] def  % stack of parsing rings
        /stack_top -1 def
        /i 0 def
        /code_len code length def

        /push_ring { /new_ring arg
            new_ring /cursor 0 put
            ring_stack length stack_top 1 add le {
                /new_stack ring_stack length 2 add array def
                0 1 stack_top { /copy_pos arg
                    ring_stack copy_pos get new_stack exch copy_pos exch put
                } for
                /ring_stack new_stack def
            } if
            /stack_top 1 adddef
            ring_stack stack_top new_ring put
            /Ring new_ring def
            Ring /components code_len 1 add i sub array put
            Ring /circumference 0.5 put  % leave room for return
        } def

        /pop_ring {
            /circumference Ring /circumference get def
            /cursor Ring /cursor get def
            /components Ring /components get def

            % temporary shenanigans - cursor might be two off the end
            components cursor 1 sub get length 0 eq {
                /cursor -1 adddef
            } if

            /end_token <<
                /otype /return
                /xflag false
                /aflag false
                /position circumference 0.5 add
                /name /RETURN
                /parent Ring
            >> def
            components cursor end_token put
            /cursor 1 adddef
            /components components 0 cursor getinterval def
            /circumference 0.5 adddef
            /radius circumference PI div half def
            % find largest dependent ring
            /max_sub 0.5 def
            /ring_spans <<>> def
            % also helpful to have an ordered list
            /ring_components components length array def
            /rci 0 def
            components { /component arg
                /angle component /position get circumference div 360 mul def
                component /angle angle put
                component /ring known {
                    component /ring_angle angle put
                    /c_ring component /ring get def
                    /sub_offset
                        c_ring /full_radius get component /offset get add 
                        def
                    sub_offset max_sub gt {
                        /max_sub sub_offset def
                    } if
                    ring_components rci component put
                    /rci 1 adddef
                    % we need:
                    % angle
                    % center_offset (ring radius plus offset)
                    % angle span (radius in either direction)
                    /center_offset radius component /offset get add def
                    /angle_span c_ring /full_radius get center_offset div asin def
                    ring_spans component <<
                        /ring c_ring
                        /full_radius c_ring /full_radius get
                        /ring_angle angle
                        /center_offset center_offset
                        /angle_span angle_span
                    >> put
                } if
            } forall
            /ring_components ring_components 0 rci 1 add getinterval def
            ring_spans length 1 gt {
                % check for everyone having room
                /total_spans 0 def
                ring_spans { /ring_span arg /component arg
                    ring_span /angle_span get 2 mul total_spans add
                    /total_spans arg
                } forall
                Ring /total_spans total_spans put
                total_spans 360 gt {
                    /adjustment 360 total_spans div def
                    /angle_tracker 0 def
                    ring_spans { /ring_span arg /component arg
                        /full_radius ring_span /full_radius get def
                        /increase
                            full_radius
                            ring_span /angle_span get sin adjustment mul div
                            ring_span /center_offset get sub
                        def
                        /c_ring component /ring get def
                        /new_offset component /offset get increase add def
                        component /offset new_offset put
                        /angle_span full_radius new_offset radius add div asin def
                        component /ring_angle angle_tracker angle_span add put
                        /angle_tracker angle_span 2 mul adddef

                        /sub_offset
                            c_ring /full_radius get component /offset get add 
                            def
                        sub_offset max_sub gt {
                            /max_sub sub_offset def
                        } if

                    } forall
                } if
                % check for jostling
            } if

            /full_radius radius max_sub add def

            Ring /components components put
            Ring /circumference circumference put
            Ring /radius radius put
            Ring /full_radius full_radius put

            /stack_top stack_top 1 sub def
            stack_top 0 ge {
                /Ring ring_stack stack_top get def
            } if
        } def

        /find_offset [/source /inner_ring] {
            source /offset
            inner_ring /full_radius get ring_spacing add put
        } simplefunc

        input_ring push_ring
        
        0 1 code_len 1 sub { /i arg
            /Token << >> def
            /parent Ring def
            /components Ring /components get def
            components Ring /cursor get Token put
            Ring dup /cursor get 1 add /cursor exch put
            % careful not to execute code piece before cvlit
            code i get
            dup type cvlit /otype arg
            dup xcheck /xflag arg
            cvlit /literal arg
            /aflag otype /arraytype eq def
            /rpush false def
            literal buffer cvs ([) eq {
                /array_ring << /rtype /array >> def
                Token /ring array_ring put
                /aflag true def
                /rpush true def
            } if
            literal buffer cvs (]) eq {
                % don't otherwise deal with this token
                /inner_ring Ring def
                pop_ring
                /source_token Ring /components get Ring /cursor get 1 sub get def
                source_token inner_ring find_offset
            } {

                kerning {
                    aflag {
                        0.75
                    } {
                        sigil_bank literal known {
                            1.25
                        } {
                            literal buffer cvs stringwidth pop ( ) stringwidth pop add
                        } ifelse
                    } ifelse
                    otype /nametype eq {
                        1.25 max
                    } if
                } {
                    1
                } ifelse
                /width arg
                /position Ring /circumference get width half add def
                Ring /circumference width addput

                [/otype /xflag /aflag /position /width /parent] {
                    Token exch dup cvx exec put
                } forall

                % this only works for executable arrays
                otype /arraytype eq {
                    /inner_ring <<
                        /rtype xflag { /xarray } { /array } ifelse
                    >> def
                    Token /ring inner_ring put
                    inner_ring literal parsecode
                    Token inner_ring find_offset
                } {
                    Token /name literal put
                } ifelse
                rpush {
                    Token /ring get push_ring
                } if
            } ifelse
        } for
        pop_ring
    end
} def

/mystical {
    gsave
        10 dict begin
            /input_code arg
            % parse into Ring object
            /spell << /rtype /xarray >> def
            spell input_code parsecode
            spell /full_radius get recip dup scale
            18 recip setlinewidth
            spell draw_ring
            code cvx exec
        end
    grestore
} def

%%EndProlog

sigil_bank /dot {
    gsave
        2 recip softscale
        0 0 1 -90 90 arc closepath nstroke
        0 0 0.5 circle nstroke
        -1 1 goto 0 1 goto nstroke
    grestore
} put
/code {
    /dot {currentlinewidth 1.5 mul 0 360 arc fill } def
    0 0 1 0 360 arc stroke
    0 0 0.5 180 360 arc
    0 0 0.375 360 180 arcn closepath
    fill
    2 {
        0.375 dup dot
        gsave
            0.375 dup translate
            5 {
                0 0 moveto 0.25 0 lineto stroke
                45 rotate
            } repeat
        grestore
        -1 1 scale
    } repeat
    [ 0 45 135 180 225 -45 ] {
        gsave
            rotate
            1 0 moveto
            2 0 lineto stroke
        grestore
    } forall
    << /a 1 /b 2
        /c [
            [
                [ 1 2 3 4 5 6 7 8 9 0]
            ]
            [
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
            ]
            [
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
            ]
            [
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
            ]
            [
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
            ]
            [
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
            ]
            [
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
            ]
            [
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
                [ 1 2 3 4 5 6 7 8 9 0]
            ]
        ]
    >> pop
} cvlit def

72 softscale
4.25 5.5 translate
4 dup scale
code mystical
showpage
