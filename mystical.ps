%!

% arg and dict_safe_func are more generally needed

(dmmlib/base.ps) run

/mystical_dict 30 dict def
mystical_dict begin

% load other dmmlib functions inside mystical_dict 
% to avoid polluting user namespace
(dmmlib/textbase.ps) run
(dmmlib/lines.ps) run
(dmmlib/polar.ps) run


/ring_debug false def
/type_debug false def
% ring_spacing is distance from parent ring radius to child ring full_radius
% ring_spacing needs to be at least 1
/ring_spacing 2 def
/ring_width 1 def
/std_sigil_width 1.25 def
% sibling_spacing is distance between rings with same parent
/sibling_spacing 0.5 def
/sibling_hs sibling_spacing half def
/ring_halfwidth ring_width half def
/buffer 100 string def
/Zapf-Chancery 0.5 selectfont
/nonsigil_spacing 0.125 def
/cartouche_radius 0.25 def
/kerning true def
/nib_angle -60 def

/nib_matrix matrix currentmatrix def
/set_nib_matrix {
    /nib_matrix matrix currentmatrix def
} def
/nstroke {
    gsave
        nib_matrix setmatrix
        24 recip setlinewidth
        nib_angle rotate
        0.5 1 scale
        0.5 callistroke
    grestore
    newpath
} def
/ndot {
    gsave
        translate
        % nib_matrix setmatrix
        nib_angle rotate
        0.75 1 scale
        0 0 16 recip spcircle fill
    grestore
} def
% /nstroke {stroke} def

/draw_ring [/Spell] {
    Spell begin
        24 recip setlinewidth
        set_nib_matrix
        % borders based on rtype
        rtype /dicttype eq {
            components length circumference cvi maximum
            dup { radius ring_halfwidth add 0 goto } circrepeat
            closepath whitefill nstroke
            dup { radius ring_halfwidth 0.75 mul add 0 goto } circrepeat
            closepath nstroke
            { radius ring_halfwidth sub 0 goto } circrepeat
            closepath nstroke
        } {
            0 0 radius ring_halfwidth add circle whitefill nstroke
            0 0 radius ring_halfwidth sub circle nstroke
        } ifelse
        % draw each ring element
        components { /Token arg
            gsave
                Token /aflag get {
                    Token draw_link
                } if
                Token /aflag get not Token /defligature known or {
                    Token draw_sigil
                } if
            grestore
        } forall
        % star for xarray
        rtype /xarray eq {
            /comp_n components length def
            /star_radius radius ring_halfwidth sub def
            comp_n 2 le {
                5 { star_radius half 0 goto } 2 schlafrepeat closepath nstroke
            } {
                /full_step comp_n 2 mul 5 idiv def
                /star_rings comp_n full_step gcd def
                /star_points comp_n star_rings idiv def
                /star_step full_step star_rings idiv def
                0 1 star_rings 1 sub {
                    gsave
                        % dup star_rings div 360 mul setkatebowcolor
                        360 comp_n div mul rotate
                        star_points {star_radius 0 goto} star_step schlafrepeat 
                        closepath nstroke
                    grestore
                } for
            } ifelse
        } if
        % debug ring positions
        ring_debug {
            gsave
                1 0 0 setrgbcolor
                0 0 radius circle stroke
                0 1 0 setrgbcolor
                0 0 full_radius circle stroke
            grestore
        } if
    end
} 0 false dict_safe_func

% determine if a token should be drawn in a triangle
/isname {
    dup /otype get /nametype eq exch /xflag get not and
} def

% sigil_bank is in the other file
(sigils.ps) run
/draw_sigil [/Token] {
    Token begin
    gsave
        angle rotate
        parent /radius get 0 translate
        set_nib_matrix
        Token isname {
            gsave
                3 {
                    -1 0 goto
                } circrepeat closepath nstroke
            grestore
        } if
        sigil_bank name known otype /stringtype ne and {
            gsave
                otype /return ne {
                    90 rotate
                } if
                otype /stringtype eq {
                    % sigil cartouche
                    0 0 ring_halfwidth spcircle nstroke
                } if
                otype /return ne {
                    0.75 softscale
                } if
                sigil_bank name get exec
                otype /return eq parent /root known and {
                    0.5 0 goto 1 0 goto nstroke
                } if
            grestore
        } {
            90 rotate
            gsave
                /textrad parent /radius get def
                0 textrad translate
                otype /stringtype eq {
                    name
                } {
                    name buffer cvs
                } ifelse
                textrad neg circle_center_show
                otype /stringtype eq {
                    /cartouche_outer_width width nonsigil_spacing sub def
                    cartouche_outer_width cartouche_radius 2 mul ge {
                        /cartouche_inner_width cartouche_outer_width cartouche_radius 2 mul sub def
                        /text_angle cartouche_inner_width PI textrad mul div 180 mul half def
                        /left_angle -90 text_angle sub def
                        /right_angle -90 text_angle add def
                        text_angle 90 gt {
                            0 0 textrad cartouche_radius sub left_angle -90 sparc
                            0 0 textrad cartouche_radius sub -90 right_angle sparc
                        } {
                            0 0 textrad cartouche_radius sub left_angle right_angle sparc
                        } ifelse
                        right_angle rotate
                        textrad 0 cartouche_radius 180 0 sparcn
                        right_angle neg rotate
                        text_angle 90 gt {
                            0 0 textrad cartouche_radius add right_angle -90 sparcn
                            0 0 textrad cartouche_radius add -90 left_angle sparcn
                        } {
                            0 0 textrad cartouche_radius add right_angle left_angle sparcn
                        } ifelse
                        left_angle rotate
                        textrad 0 cartouche_radius 0 180 sparcn
                        left_angle neg rotate
                        closepath
                        nstroke
                    } {
                        % too small for cartouche, ellipse
                        0 textrad neg cartouche_outer_width half cartouche_radius 0 180 spell 
                        0 textrad neg cartouche_outer_width half cartouche_radius 180 0 spell
                        nstroke
                    } ifelse
                } if
            grestore
        } ifelse
        type_debug {
            otype /return ne {
                0 -0.75 translate
                2 recip softscale
                xflag {
                    /Times-Bold 0.5 selectfont
                } if
                otype buffer cvs centershow
            } if
        } if
    grestore
    end
} 0 false dict_safe_func
/draw_link [/Token] {
    Token begin
    gsave
        /r0 parent /radius get def
        /r4 r0 Token /offset get add def 
        Token /defligature known {
            % special sigil handling
            /r0 ring_halfwidth adddef
        } if
        /r3 r4 ring /radius get sub ring_halfwidth sub def
        /rstep r3 r0 sub 3 div def
        /r1 r0 rstep add def
        /r2 r1 rstep add def
        angle rotate
        /local_angle ring_angle angle sub def
        set_nib_matrix
        r0 0 polar goto
        r1 0 polar
        r2 local_angle polar
        r3 local_angle polar curveto nstroke
        r0 0 polar
        ring /rtype get /xarray eq {
            0.125 spcircle whitefill nstroke
        } {
            ndot
        } ifelse
        local_angle rotate
        r4 0 translate
        180 rotate
        ring draw_ring
    grestore
    % ring debug
    ring_debug {
        gsave
            1 0.5 0 setrgbcolor
            gsave
                ring_angle rotate
                0 0 goto
                0 0 r4 
                ring /full_radius get r4 div asin dup neg arcn
                closepath stroke
            grestore
        grestore
    } if
    end
} 0 false dict_safe_func

% end of drawing functions

/handlecode { /code arg /Ring arg
    Ring code 0 parsecode pop
    Ring layoutring
} def

% modifies Ring in place to reflect the instructions starting at code[code_pos]
/parsecode [/Ring /code /code_pos] {
    10 dict begin
        % Ring: Ring object to write into, type is set
        % code:  input code
        % code_pos: position in code being parsed

        /i 0 def
        /code_len code length def

        Ring /cursor 0 put
        Ring /components code_len 1 add code_pos sub array put
        Ring /circumference 0.5 put  % leave room for return
        
        code_len 0 gt {
            {
                /Token << >> def
                /parent Ring def
                /components Ring /components get def
                /cursor Ring /cursor get def
                components cursor Token put
                % careful not to execute code piece before cvlit
                code code_pos get
                dup type cvlit /otype arg
                dup xcheck /xflag arg
                cvlit /literal arg
                /aflag otype /arraytype eq def
                otype /stringtype eq {
                    /literal_s literal def
                } {
                    /literal_s literal buffer cvs def
                } ifelse

                % check for def-ligature
                /skip_token false def
                Ring /rtype get /xarray eq literal /def eq xflag and and {
                    cursor 2 ge {
                        % prev is true circle
                        /previous components cursor 1 sub get def
                        /prevprev components cursor 2 sub get def
                        previous /aflag get previous isname not and {
                            prevprev /aflag get not prevprev isname and {
                                % set up ligature - add ring info to name
                                [/ring /aflag] { /field arg
                                    prevprev field
                                    previous field get 
                                    put
                                } forall
                                Ring /circumference previous /width get neg addput
                                prevprev /defligature true put
                                /cursor -2 adddef
                                /skip_token true def
                                /code_pos 1 adddef
                            } if
                        } if
                    } if
                } if
                /cursor 1 adddef
                Ring /cursor cursor put
                skip_token not {
                    % [ for vi
                    % don't otherwise deal with these tokens
                    literal_s (]) eq { exit } if
                    literal_s (>>) eq { exit } if
                    literal_s ([) eq literal_s (<<) eq or {
                        % ] for vi
                        /array_ring << /rtype literal_s (<<) eq {/dicttype} {/array} ifelse >> def
                        Token /ring array_ring put
                        Token /signal true put
                        /code_pos 1 adddef
                        array_ring code code_pos parsecode /code_pos arg
                        Token /name array_ring /rtype get put
                        /aflag true def
                    } {
                        % Handle recursion for arrays
                        otype /arraytype eq otype /dicttype eq or {
                            /inner_ring <<
                                /rtype xflag { 
                                    /xarray 
                                } { 
                                    otype /arraytype eq {
                                        /array 
                                    } {
                                        /dicttype
                                    } ifelse
                                } ifelse
                            >> def
                            otype /dicttype eq {
                                /literal [literal {} forall] def
                            } if
                            Token /ring inner_ring put
                            inner_ring literal 0 parsecode pop
                            Token /name inner_ring /rtype get put
                            /aflag true def
                        } {
                            Token /name literal put
                        } ifelse
                    } ifelse
                    kerning {
                        aflag {
                            0.5
                        } {
                            sigil_bank literal known otype /stringtype ne and {
                                std_sigil_width
                            } {
                                literal_s stringwidth pop
                                nonsigil_spacing add
                                otype /stringtype eq {
                                    nonsigil_spacing add
                                } if
                            } ifelse
                        } ifelse
                        % even if text is short names must be sigil-width
                        currentdict isname {
                            std_sigil_width 1.25 mul max
                        } if
                    } {
                        std_sigil_width
                    } ifelse
                    /width arg
                    /position Ring /circumference get width half add def
                    Ring /circumference width addput

                    [/otype /xflag /aflag /position /width /parent] {
                        Token exch dup cvx exec put
                    } forall

                    /code_pos 1 adddef
                } if
                code_pos code length ge { exit } if
            } loop
            % temporary shenanigans - cursor might be two off the end
            components Ring /cursor get 1 sub get length 0 eq {
                Ring /cursor -1 addput
            } if
        } if
        /circumference Ring /circumference get def
        /cursor Ring /cursor get def
        /components Ring /components get def

        /end_token <<
            /otype /return
            /xflag false
            /aflag false
            /position circumference 0.5 add
            /name Ring /rtype get /xarray eq { /RETURN } { /COMPLETE } ifelse
            /parent Ring
        >> def
        components cursor end_token put
        /cursor 1 adddef

        % determine ring dimensions
        /components components 0 cursor getinterval def
        /circumference 0.5 adddef

        % set angles of all sigils before messing with circumference
        components { /component arg
            /angle component /position get circumference div 360 mul def
            component /angle angle put
            component /position undef
        } forall

        /circumference circumference 2 PI mul maximum def
        /radius circumference PI div half def

        Ring /circumference circumference put
        Ring /radius radius put
        Ring /components components put
        code_pos
    end
} 1 false dict_safe_func

/find_offset { /inner_ring arg /source arg
    source /offset
    inner_ring /full_radius get ring_spacing add put
} def

/layoutring [/Ring] {
    10 dict begin
        /components Ring /components get def
        /radius Ring /radius get def
        /circumference Ring /circumference get def
        components {
            /Token arg
            Token /ring known {
                /inner_ring Token /ring get def
                inner_ring layoutring
                Token inner_ring find_offset
            } if
        } forall

        % layout
        % find largest dependent ring
        /max_sub 0.5 def
        % ordered list of components and their span info
        /ring_components components length array def
        /rci 0 def
        components { /component arg
            component /ring known {
                /angle component /angle get def
                component /ring_angle angle put
                /c_ring component /ring get def
                /sub_offset
                    c_ring /full_radius get component /offset get add 
                    def
                sub_offset max_sub gt {
                    /max_sub sub_offset def
                } if
                % we need:
                % angle
                % center_offset (ring radius plus offset)
                % angle span (radius in either direction)
                /center_offset radius component /offset get add def
                /angle_span c_ring /full_radius get sibling_hs add center_offset div asin def
                /ring_span <<
                    /ring c_ring
                    /full_radius c_ring /full_radius get
                    /ring_angle angle
                    /center_offset center_offset
                    /angle_span angle_span
                >> def
                ring_components rci [component ring_span] put
                /rci 1 adddef
            } if
        } forall

        /ring_components ring_components 0 rci getinterval def
        ring_components length 1 gt {
            % check for everyone having room
            /total_spans 0 def
            ring_components { aload pop /ring_span arg /component arg
                ring_span /angle_span get 2 mul total_spans add
                /total_spans arg
            } forall
            Ring /total_spans total_spans put
            total_spans 360 gt {
                % not enough room, push everyone out and space evenly
                /adjustment 360 total_spans div def
                /angle_tracker 0 def
                ring_components { aload pop /ring_span arg /component arg
                    /full_radius ring_span /full_radius get def
                    /new_span ring_span /angle_span get adjustment mul def
                    /increase
                        full_radius sibling_hs add
                        new_span sin div
                        ring_span /center_offset get sub
                    def
                    /c_ring component /ring get def
                    /new_offset component /offset get increase add def
                    component /offset new_offset put
                    /angle_span full_radius sibling_hs add new_offset radius add div asin def
                    component /ring_angle angle_tracker angle_span add put
                    /angle_tracker angle_span 2 mul adddef

                    /sub_offset
                        c_ring /full_radius get component /offset get add 
                        def
                    sub_offset max_sub gt {
                        /max_sub sub_offset def
                    } if
                } forall
            } {
                % check for jostling
                % create differential list
                /diff_list ring_components length 1 add array def
                /last_component ring_components length 1 sub def
                /last_diff ring_components length def
                diff_list 0 ring_components 0 get 1 get
                    dup /ring_angle get exch /angle_span get sub
                put
                1 1 last_component { /i arg
                    diff_list i
                    /span_a ring_components i 1 sub get 1 get def
                    /span_b ring_components i get 1 get def
                    span_b dup /ring_angle get exch /angle_span get sub
                    span_a dup /ring_angle get exch /angle_span get add sub 
                    put
                } for
                diff_list last_diff ring_components last_component get 1 get
                    dup /ring_angle get exch /angle_span get add
                    360 exch sub
                put

                % calculate optimal diff_list
                % move negative edges to first positive neighbor
                0 1 last_diff { /i arg
                    {
                        diff_list i get 0 ge { exit } if
                        /left i 1 sub def
                        {
                            left 0 lt {exit} if
                            diff_list left get 0 gt { exit } if
                            /left -1 adddef
                        } loop
                        /right i 1 add def
                        {
                            right last_diff gt {exit} if
                            diff_list right get 0 gt { exit } if
                            /right 1 adddef
                        } loop
                        left 0 ge {
                            right last_diff le {
                                % both sides available
                                /remove_amount 
                                    diff_list left get
                                    diff_list right get minimum
                                    diff_list i get half minimum
                                def
                                diff_list left remove_amount addput
                                diff_list right remove_amount addput
                                diff_list i remove_amount -2 mul addput
                            } {
                                % only left is available
                                /remove_amount diff_list left get diff_list i get minimum def
                                diff_list left remove_amount addput
                                diff_list i remove_amount neg addput
                            } ifelse
                        } {
                            % left is off side
                            right last_diff le {
                                % only right is available
                                /remove_amount diff_list right get diff_list i get minimum def
                                diff_list right remove_amount addput
                                diff_list i remove_amount neg addput
                            } {
                                [(both sides off)] == die
                            } ifelse
                        } ifelse
                        exit
                    } loop
                } for
                % spread negative centers to positive neighbors
                % update ring_angles to match diff_list
                /ring_cursor 0 def
                0 1 last_component { /i arg
                    /current_component ring_components i get def
                    /ring_cursor diff_list i get adddef
                    /ring_cursor current_component 1 get /angle_span get adddef
                    current_component 0 get /ring_angle ring_cursor put
                    /ring_cursor current_component 1 get /angle_span get adddef
                } for

            } ifelse
        } if

        /full_radius radius max_sub add def

        Ring /components components put
        Ring /circumference circumference put
        Ring /radius radius put
        Ring /full_radius full_radius put
    end
} 0 false dict_safe_func

end     % now out of mystical_dict

/mystical_get_spell {
    mystical_dict begin
    10 dict begin
        /input_code arg
        % determine type
        /xflag false def
        /input_code load xcheck {
            /xflag true def
            currentdict /input_code get cvlit /input_code arg
        } if
        /rtype xflag { /xarray} {input_code type cvlit } ifelse def
        rtype /dicttype eq {
            % convert dict into array of k, v, k, v, ...
            /input_code [ input_code {} forall ] def
        } if
        % parse into Ring object
        /Spell << /rtype rtype /root true >> def
        Spell input_code handlecode
        Spell
    end
    end
} def

/mystical_scale_spell { /Spell arg
    Spell /full_radius get recip dup scale
} def

/mystical_draw_spell { /Spell arg
    mystical_dict begin
        gsave
            Spell mystical_scale_spell
            Spell draw_ring
        grestore
    end
} def

/mystical {
    10 dict begin
        mystical_get_spell /Spell arg
        Spell mystical_draw_spell
    end
} def

/mystical_unscaled {
    mystical_dict begin
    10 dict begin
        mystical_get_spell /Spell arg
        Spell draw_ring
    end
    end
} def

/mystical_evoke { /evocation arg
    evocation load mystical
} def

/mystical_evoke_unscaled { /evocation arg
    evocation load mystical_unscaled
} def

/mystical_make_evocation_ligature { /Spell arg /evocation arg
    % false token for label
    <<
        /name evocation /otype /nametype 
        /xflag false /aflag true
        /position 0 /angle -90 /parent <<
            /radius Spell /full_radius get neg
        >>
        /ring Spell /ring_angle -90 /offset Spell /full_radius get
        /defligature true
    >> 
} def
/mystical_draw_evocation_label { /Spell arg /evocation arg
    /ligature evocation Spell mystical_make_evocation_ligature def
    mystical_dict begin
        ligature draw_sigil
        ligature draw_link
    end
} def

/mystical_evoke_label_base { /do_scale arg /evocation arg
    evocation load mystical_get_spell /Spell arg
    gsave
        do_scale { Spell mystical_scale_spell } if
        evocation Spell mystical_draw_evocation_label
    grestore
} def

/mystical_evoke_label { true mystical_evoke_label_base } def
/mystical_evoke_label_unscaled { false mystical_evoke_label_base } def
